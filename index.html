<!DOCTYPE html>
<html>
<body style="background:#111; display:flex; flex-direction:column; align-items:center;">

<!-- SCORES & CONTROLS -->
<div style="color:white; font-family:Arial; font-size:28px; margin:10px;">
    <div id="score">Score: 0</div>
    <div id="topscore">Topscore: 0</div>
    <div style="font-size:16px; margin-top:10px;">
        Speed: <select id="speed" style="font-size:16px; padding:2px;">
            <option value="800">Slow</option>
            <option value="500">Normal</option>
            <option value="300">Fast</option>
            <option value="150">Very Fast</option>
        </select>
    </div>
</div>

<!-- SPEL -->
<canvas id="game" width="240" height="400"></canvas>

<script>
// ---------------- SCORE ----------------
let score = 0;
let topscore = parseInt(localStorage.getItem("tetris_topscore") || "0");

function updateScoreDisplay() {
    document.getElementById("score").innerText = "Score: " + score;
    document.getElementById("topscore").innerText = "Topscore: " + topscore;
}

function addScore(rows) {
    score += rows * 100;
    if (score > topscore) {
        topscore = score;
        localStorage.setItem("tetris_topscore", topscore);
    }
    updateScoreDisplay();
}

// ---------------- GELUID ----------------
const audio = new (window.AudioContext || window.webkitAudioContext)();

function playBeep(freq = 440, duration = 0.08, type="square", volume=0.15) {
    const osc = audio.createOscillator();
    const gain = audio.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    gain.gain.value = volume;
    osc.connect(gain);
    gain.connect(audio.destination);
    osc.start();
    osc.stop(audio.currentTime + duration);
}

const SFX = {
    move: () => playBeep(300, 0.05, "square", 0.08),
    rotate: () => playBeep(500, 0.06, "sawtooth", 0.1),
    drop: () => playBeep(120, 0.12, "square", 0.15),
    clear: () => playBeep(700, 0.25, "triangle", 0.25),
    gameover: () => playBeep(80, 0.6, "sine", 0.3),
};

// ---------------- CANVAS ----------------
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
ctx.scale(20, 20);

const arena = createMatrix(12, 20);

const colors = [
  null,
  "#ff4b4b", "#4bff4b", "#4b4bff",
  "#ffff4b", "#4bffff", "#ff4bff", "#ffffff",
];

// ---------------- PIECES ----------------
function createPiece(type) {
  if (type === "T") return [[0,1,0],[1,1,1],[0,0,0]];
  if (type === "O") return [[1,1],[1,1]];
  if (type === "L") return [[0,0,1],[1,1,1],[0,0,0]];
  if (type === "J") return [[1,0,0],[1,1,1],[0,0,0]];
  if (type === "I") return [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]];
  if (type === "S") return [[0,1,1],[1,1,0],[0,0,0]];
  if (type === "Z") return [[1,1,0],[0,1,1],[0,0,0]];
}

function createMatrix(w,h){
    const m=[]; while(h--) m.push(new Array(w).fill(0));
    return m;
}

function collide(arena,player){
  const [m,o]=[player.matrix,player.pos];
  for(let y=0;y<m.length;y++){
    for(let x=0;x<m[y].length;x++){
      if(m[y][x]!==0 &&
        (arena[y+o.y] && arena[y+o.y][x+o.x]) !== 0){
        return true;
      }
    }
  }
  return false;
}

function merge(arena,player){
  player.matrix.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v!==0) arena[y+player.pos.y][x+player.pos.x]=player.color;
    });
  });
}

function draw(){
  ctx.fillStyle="#000";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  arena.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v!==0){
        ctx.fillStyle=colors[v];
        ctx.fillRect(x,y,1,1);
      }
    });
  });

  drawMatrix(player.matrix,player.pos,colors[player.color]);
}

function drawMatrix(matrix,offset,color){
  matrix.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v!==0){
        ctx.fillStyle=color;
        ctx.fillRect(x+offset.x,y+offset.y,1,1);
      }
    });
  });
}

function rotate(matrix,dir){
  for(let y=0;y<matrix.length;y++){
    for(let x=0;x<y;x++){
      [matrix[x][y],matrix[y][x]]=[matrix[y][x],matrix[x][y]];
    }
  }
  if(dir>0)matrix.forEach(r=>r.reverse());
  else matrix.reverse();
}

function playerReset(){
  const pieces="TJLOSZI";
  player.matrix=createPiece(pieces[Math.floor(Math.random()*7)]);
  player.color=Math.floor(Math.random()*7)+1;

  player.pos.y=0;
  player.pos.x=(arena[0].length/2|0)-(player.matrix[0].length/2|0);

  if(collide(arena,player)){
    arena.forEach(row=>row.fill(0));
    SFX.gameover();
    score = 0;
    updateScoreDisplay();
  }
}

function arenaSweep(){
  let rows = 0;

  for(let y=arena.length-1;y>=0;y--){
    if(arena[y].every(v=>v!==0)){
      arena.splice(y,1);
      arena.unshift(new Array(12).fill(0));
      rows++;
      y++;
    }
  }
  if(rows>0){
    addScore(rows);   // â­ SCORE ENKEL VOOR GECLEARED RIJEN
    SFX.clear();
  }
}

let dropCounter=0;
let lastTime=0;
let dropInterval = parseInt(localStorage.getItem("tetris_speed") || "500");

// Initialize speed dropdown from saved preference
const speedSelect = document.getElementById("speed");
speedSelect.value = dropInterval.toString();

speedSelect.addEventListener("change", e => {
    dropInterval = parseInt(e.target.value);
    localStorage.setItem("tetris_speed", dropInterval);
});

const player={
  pos:{x:5,y:0},
  matrix:null,
  color:1,
};

function update(t=0){
  const dt=t-lastTime; lastTime=t;
  dropCounter+=dt;

  if(dropCounter>dropInterval){
    player.pos.y++;
    if(collide(arena,player)){
      player.pos.y--;
      merge(arena,player);
      SFX.drop();
      arenaSweep();
      playerReset();
    }
    dropCounter=0;
  }

  draw();
  requestAnimationFrame(update);
}

// ---------------- INPUT ----------------
document.addEventListener("keydown",e=>{
  if(e.key==="ArrowLeft"){
    player.pos.x--;
    if(collide(arena,player))player.pos.x++;
    else SFX.move();
  }
  if(e.key==="ArrowRight"){
    player.pos.x++;
    if(collide(arena,player))player.pos.x--;
    else SFX.move();
  }
  if(e.key==="ArrowDown"){
    player.pos.y++;
    if(collide(arena,player))player.pos.y--;
    else SFX.move();
  }
  if(e.key==="ArrowUp"){
    const old=JSON.parse(JSON.stringify(player.matrix));
    rotate(player.matrix,1);
    if(collide(arena,player))player.matrix=old;
    else SFX.rotate();
  }
});

playerReset();
update();
updateScoreDisplay();
</script>
</body>
</html>
