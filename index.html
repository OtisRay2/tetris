<!DOCTYPE html>
<html>
<body style="background:#111; display:flex; flex-direction:column; align-items:center;">

<!-- SCORES & CONTROLS -->
<div style="color:white; font-family:Arial; font-size:28px; margin:10px;">
    <div id="score">Score: 0</div>
    <div id="topscore">Topscore: 0</div>
    <div style="font-size:16px; margin-top:10px;">
        Name: <input id="player-name" type="text" maxlength="10" placeholder="Enter name" style="font-size:16px; padding:2px; width:100px;">
    </div>
    <div style="font-size:16px; margin-top:10px;">
        Speed: <select id="speed" style="font-size:16px; padding:2px;">
            <option value="800">Slow</option>
            <option value="500">Normal</option>
            <option value="300">Fast</option>
            <option value="150">Very Fast</option>
        </select>
    </div>
</div>

<!-- SPEL -->
<div style="display:flex; gap:10px; align-items:flex-start;">
    <!-- Next piece preview -->
    <div style="color:white; font-family:Arial; text-align:center;">
        <div style="font-size:14px; margin-bottom:5px;">NEXT</div>
        <canvas id="next-piece" width="80" height="80" style="background:#000; border:1px solid #333;"></canvas>
    </div>

    <!-- Main game -->
    <div style="position:relative;">
        <canvas id="game" width="240" height="400" style="background:#000; border:1px solid #333;"></canvas>
    <div id="gameover" style="display:none; position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); flex-direction:column; justify-content:center; align-items:center; color:white; font-family:Arial;">
        <div style="font-size:32px; font-weight:bold; color:#ff4b4b; margin-bottom:20px;">GAME OVER</div>
        <div style="font-size:18px; margin-bottom:10px;">Final Score: <span id="final-score">0</span></div>
        <div id="new-highscore" style="font-size:16px; color:#4bff4b; margin-bottom:15px; display:none;">New High Score!</div>
        <div id="highscore-display" style="font-size:14px; color:#ffff4b; margin-bottom:20px; padding:10px; background:rgba(255,255,255,0.1); border-radius:5px;">
            High Score: <span id="highscore-name">---</span> - <span id="highscore-value">0</span>
        </div>
        <button id="restart-btn" style="padding:10px 30px; font-size:18px; cursor:pointer; background:#4b4bff; color:white; border:none; border-radius:5px;">Play Again</button>
        <div style="font-size:12px; margin-top:15px; color:#888;">Press SPACE to restart</div>
    </div>
    </div>
</div>

<script>
// ---------------- GAME STATE ----------------
let gameOver = false;

// ---------------- SCORE ----------------
let score = 0;
let topscore = parseInt(localStorage.getItem("tetris_topscore") || "0");
let topscoreName = localStorage.getItem("tetris_topscore_name") || "---";

// Initialize player name from localStorage
const playerNameInput = document.getElementById("player-name");
playerNameInput.value = localStorage.getItem("tetris_player_name") || "";

// Save player name when changed
playerNameInput.addEventListener("input", e => {
    localStorage.setItem("tetris_player_name", e.target.value);
});

function getPlayerName() {
    return playerNameInput.value.trim() || "Anonymous";
}

function updateScoreDisplay() {
    document.getElementById("score").innerText = "Score: " + score;
    document.getElementById("topscore").innerText = "Topscore: " + topscore + " (" + topscoreName + ")";
}

function addScore(rows) {
    score += rows * 100;
    if (score > topscore) {
        topscore = score;
        topscoreName = getPlayerName();
        localStorage.setItem("tetris_topscore", topscore);
        localStorage.setItem("tetris_topscore_name", topscoreName);
    }
    updateScoreDisplay();
}

// ---------------- GAME OVER ----------------
function showGameOver() {
    gameOver = true;
    const isNewHighScore = score > 0 && score >= topscore;

    // If new high score, update with current player name
    if (isNewHighScore) {
        topscore = score;
        topscoreName = getPlayerName();
        localStorage.setItem("tetris_topscore", topscore);
        localStorage.setItem("tetris_topscore_name", topscoreName);
        updateScoreDisplay();
    }

    document.getElementById("final-score").innerText = score;
    document.getElementById("new-highscore").style.display = isNewHighScore ? "block" : "none";
    document.getElementById("highscore-name").innerText = topscoreName;
    document.getElementById("highscore-value").innerText = topscore;
    document.getElementById("gameover").style.display = "flex";
}

function restartGame() {
    gameOver = false;
    score = 0;
    updateScoreDisplay();
    arena.forEach(row => row.fill(0));
    document.getElementById("gameover").style.display = "none";
    nextPiece = null;  // Reset next piece queue
    playerReset();
}

// ---------------- GELUID ----------------
const audio = new (window.AudioContext || window.webkitAudioContext)();

function playBeep(freq = 440, duration = 0.08, type="square", volume=0.15) {
    const osc = audio.createOscillator();
    const gain = audio.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    gain.gain.value = volume;
    osc.connect(gain);
    gain.connect(audio.destination);
    osc.start();
    osc.stop(audio.currentTime + duration);
}

const SFX = {
    move: () => playBeep(300, 0.05, "square", 0.08),
    rotate: () => playBeep(500, 0.06, "sawtooth", 0.1),
    drop: () => playBeep(120, 0.12, "square", 0.15),
    clear: () => playBeep(700, 0.25, "triangle", 0.25),
    gameover: () => playBeep(80, 0.6, "sine", 0.3),
};

// ---------------- CANVAS ----------------
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
ctx.scale(20, 20);

// Next piece preview canvas
const nextCanvas = document.getElementById("next-piece");
const nextCtx = nextCanvas.getContext("2d");
nextCtx.scale(20, 20);

const arena = createMatrix(12, 20);

// Next piece tracking
let nextPiece = null;
let nextColor = 1;

const colors = [
  null,
  "#ff4b4b", "#4bff4b", "#4b4bff",
  "#ffff4b", "#4bffff", "#ff4bff", "#ffffff",
];

// ---------------- PIECES ----------------
function createPiece(type) {
  if (type === "T") return [[0,1,0],[1,1,1],[0,0,0]];
  if (type === "O") return [[1,1],[1,1]];
  if (type === "L") return [[0,0,1],[1,1,1],[0,0,0]];
  if (type === "J") return [[1,0,0],[1,1,1],[0,0,0]];
  if (type === "I") return [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]];
  if (type === "S") return [[0,1,1],[1,1,0],[0,0,0]];
  if (type === "Z") return [[1,1,0],[0,1,1],[0,0,0]];
}

function createMatrix(w,h){
    const m=[]; while(h--) m.push(new Array(w).fill(0));
    return m;
}

function collide(arena,player){
  const [m,o]=[player.matrix,player.pos];
  for(let y=0;y<m.length;y++){
    for(let x=0;x<m[y].length;x++){
      if(m[y][x]!==0 &&
        (arena[y+o.y] && arena[y+o.y][x+o.x]) !== 0){
        return true;
      }
    }
  }
  return false;
}

function merge(arena,player){
  player.matrix.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v!==0) arena[y+player.pos.y][x+player.pos.x]=player.color;
    });
  });
}

function draw(){
  ctx.fillStyle="#000";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  arena.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v!==0){
        ctx.fillStyle=colors[v];
        ctx.fillRect(x,y,1,1);
      }
    });
  });

  drawMatrix(player.matrix,player.pos,colors[player.color]);
}

function drawMatrix(matrix,offset,color){
  matrix.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v!==0){
        ctx.fillStyle=color;
        ctx.fillRect(x+offset.x,y+offset.y,1,1);
      }
    });
  });
}

function drawNextPiece(){
  nextCtx.fillStyle="#000";
  nextCtx.fillRect(0,0,4,4);

  if(nextPiece){
    const offsetX = (4 - nextPiece[0].length) / 2;
    const offsetY = (4 - nextPiece.length) / 2;
    nextPiece.forEach((row,y)=>{
      row.forEach((v,x)=>{
        if(v!==0){
          nextCtx.fillStyle=colors[nextColor];
          nextCtx.fillRect(x+offsetX,y+offsetY,1,1);
        }
      });
    });
  }
}

function rotate(matrix,dir){
  for(let y=0;y<matrix.length;y++){
    for(let x=0;x<y;x++){
      [matrix[x][y],matrix[y][x]]=[matrix[y][x],matrix[x][y]];
    }
  }
  if(dir>0)matrix.forEach(r=>r.reverse());
  else matrix.reverse();
}

function getRandomPiece(){
  const pieces="TJLOSZI";
  return {
    matrix: createPiece(pieces[Math.floor(Math.random()*7)]),
    color: Math.floor(Math.random()*7)+1
  };
}

function playerReset(){
  // Use next piece if available, otherwise generate new one
  if(nextPiece){
    player.matrix = nextPiece;
    player.color = nextColor;
  } else {
    const piece = getRandomPiece();
    player.matrix = piece.matrix;
    player.color = piece.color;
  }

  // Generate next piece
  const next = getRandomPiece();
  nextPiece = next.matrix;
  nextColor = next.color;
  drawNextPiece();

  player.pos.y=0;
  player.pos.x=(arena[0].length/2|0)-(player.matrix[0].length/2|0);

  if(collide(arena,player)){
    SFX.gameover();
    showGameOver();
  }
}

function arenaSweep(){
  let rows = 0;

  for(let y=arena.length-1;y>=0;y--){
    if(arena[y].every(v=>v!==0)){
      arena.splice(y,1);
      arena.unshift(new Array(12).fill(0));
      rows++;
      y++;
    }
  }
  if(rows>0){
    addScore(rows);   // â­ SCORE ENKEL VOOR GECLEARED RIJEN
    SFX.clear();
  }
}

let dropCounter=0;
let lastTime=0;
let dropInterval = parseInt(localStorage.getItem("tetris_speed") || "500");

// Initialize speed dropdown from saved preference
const speedSelect = document.getElementById("speed");
speedSelect.value = dropInterval.toString();

speedSelect.addEventListener("change", e => {
    dropInterval = parseInt(e.target.value);
    localStorage.setItem("tetris_speed", dropInterval);
});

const player={
  pos:{x:5,y:0},
  matrix:null,
  color:1,
};

function update(t=0){
  if(gameOver){
    requestAnimationFrame(update);
    return;
  }

  const dt=t-lastTime; lastTime=t;
  dropCounter+=dt;

  if(dropCounter>dropInterval){
    player.pos.y++;
    if(collide(arena,player)){
      player.pos.y--;
      merge(arena,player);
      SFX.drop();
      arenaSweep();
      playerReset();
    }
    dropCounter=0;
  }

  draw();
  requestAnimationFrame(update);
}

// ---------------- INPUT ----------------
document.addEventListener("keydown",e=>{
  if(e.key===" " && gameOver){
    restartGame();
    return;
  }
  if(gameOver) return;

  if(e.key==="ArrowLeft"){
    player.pos.x--;
    if(collide(arena,player))player.pos.x++;
    else SFX.move();
  }
  if(e.key==="ArrowRight"){
    player.pos.x++;
    if(collide(arena,player))player.pos.x--;
    else SFX.move();
  }
  if(e.key==="ArrowDown"){
    player.pos.y++;
    if(collide(arena,player))player.pos.y--;
    else SFX.move();
  }
  if(e.key==="ArrowUp"){
    const old=JSON.parse(JSON.stringify(player.matrix));
    rotate(player.matrix,1);
    if(collide(arena,player))player.matrix=old;
    else SFX.rotate();
  }
});

// Restart button click handler
document.getElementById("restart-btn").addEventListener("click", restartGame);

playerReset();
update();
updateScoreDisplay();
</script>
</body>
</html>
